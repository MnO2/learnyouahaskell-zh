<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <style>
            @import url(css/style.css);
            @import url(css/feedback.css);
        </style>
        <script src="js/jquery.js"></script>
        <script src="js/jquery.chili-2.2.js"></script>
        <script src="js/script.js"></script>
        <script src="js/html2canvas.js"></script>
        <script src="js/jsfeedback.js"></script>
        <script>
             ChiliBook.recipeFolder = "js/chili/";  
             ChiliBook.automaticSelector = "pre";
        </script>
        <script>
            $(function(){
                $('#feedback').click(function(){
                    $('body').feedback();
                })
            });
        </script>
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-32830659-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
        <title>Functors, Applicative Functors與Monoids</title>
    </head>
    <body>
        <div id="header">
            <img id="beta" alt="beta" src="img/beta.png" />
        </div>

        <div id="main">
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="functionally-solving-problems.html">函數式地思考來解決問題</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="a-fistful-of-monads.html">來看看幾種Monad</a><img src="img/nxt.png"></img></li>
            </ul>
            <a name="Functors, Applicative Functors與Monoids"></a><h1>Functors, Applicative Functors與Monoids</h1><p>Haskell的一些特色，像是純粹性，高階函數，algebraic data types，typeclasses，這些讓我們可以從更高的角度來看到polymorphism這件事。不像OOP當中需要從龐大的型態階層來思考。我們只需要看看手邊的型態的行為，將他們跟適當地typeclass對應起來就可以了。像<code>Int</code>的行為跟很多東西很像。好比說他可以比較相不相等，可以從大到小排列，也可以將他們一一窮舉出來。</p><p>Typeclass的運用是很隨意的。我們可以定義自己的資料型態，然後描述他可以怎樣被操作，跟typeclass關聯起來便定義了他的行為。由於Haskell強大的型態系統，這讓我們只要讀函數的型態宣告就可以知道很多資訊。typeclass可以定義得很抽象很general。我們之前有看過typeclass定義了可以比較兩個東西是否相等，或是定義了可以比較兩個東西的大小。這些是既抽象但又描述簡潔的行為，但我們不會認為他們有什麼特別之處，因為我們時常碰到他們。最近我們看過了functor，基本上他們是一群可以被map over的物件。這是其中一個例子能夠抽象但又漂亮地描述行為。在這一章中，我們會詳加闡述functors，並會提到比較強一些的版本，也就是applicative functors。我們也會提到monoids。</p><a name="溫習Functors"></a><h2>溫習Functors</h2><img src="img/frogtor.png" style="float:right"></img><p>我們已經在之前的章節提到functors。如果你還沒讀那個章節，也許你應該先去看看。或是你直接假裝你已經讀過了。</p><p>來快速複習一下：Functors是可以被map over的物件，像是lists，<code>Maybe</code>，trees等等。在Haskell中我們是用<code>Functor</code>這個typeclass來描述他。這個typeclass只有一個method，叫做<code>fmap</code>，他的型態是<code>fmap :: (a -> b) ->  fa -> f b</code>。這型態說明了如果給我一個從<code>a</code>映到<code>b</code>的函數，以及一個裝了<code>a</code>的盒子，我會回給你一個裝了<code>b</code>的盒子。就好像用這個函數將每個元素都轉成<code>b</code>一樣</p><blockquote><p><b>給一點建議</b>。這盒子的比喻嘗試讓你抓到些functors是如何運作的感覺。在之後我們也會用相同的比喻來比喻applicative functors跟monads。在多數情況下這種比喻是恰當的，但不要過度引申，有些functors是不適用這個比喻的。一個比較正確的形容是functors是一個計算語境(computational context)。這個語境可能是這個computation可能帶有值，或是有可能會失敗(像<code>Maybe</code>跟<code>Either a</code>)，或是他可能有多個值(像lists)，等等。</p></blockquote><p>如果一個type constructor要是<code>Functor</code>的instance，那他的kind必須是<code>* -> *</code>，這代表他必須剛好接受一個type當作type parameter。像是<code>Maybe</code>可以是Functor的一個instance，因為他接受一個type parameter，來做成像是<code>Maybe Int</code>，或是<code>Maybe String</code>。如果一個type constructor接受兩個參數，像是<code>Either</code>，我們必須給他兩個type parameter。所以我們不能這樣寫：<code>instance Functor Either where</code>，但我們可以寫<code>instance Functor (Either a) where</code>，如果我們把<code>fmap</code>限縮成只是<code>Either a</code>的，那他的型態就是<code>fmap :: (b -> c) -> Either a b -> Either a c</code>。就像你看到的，<code>Either a</code>的是固定的一部分，因為<code>Either a</code>只恰好接受一個type parameter，但<code>Either</code>則要接球兩個type parameters。這樣fmap的型態變成<code>fmap :: (b -> c) -> Either b -> Either c</code>，這不太合理。</p><p>我們知道有許多型態都是<code>Functor</code>的instance，像是<code>[]</code>，<code>Maybe</code>，<code>Either a</code>以及我們自己寫的<code>Tree</code>。我們也看到了如何用一個函數map他們。在這一章節，我們再多舉兩個例子，也就是<code>IO</code>跟<code>(->) r</code>。</p><p>如果一個值的型態是<code>IO String</code>，他代表的是一個會被計算成String結果的I/O action。我們可以用do syntax來把結果綁定到某個名稱。我們之前把I/O action比喻做長了腳的盒子，會到真實世界幫我們取一些值回來。我們可以檢視他們取了什麼值，但一旦看過，我們必須要把值放回盒子中。用這個比喻，<code>IO</code>的行為就像是一個functor。</p><p>我們來看看<code>IO</code>是怎麼樣的一個<code>Functor</code>instance。當我們<code>fmap</code>用一個function來map over I/O action時，我們會想要拿回一個裝著已經用function映射過值的I/O action。</p><pre class="code">instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)</pre><p>對一個I/O action做map over動作的結果仍會是一個I/O action，所以我們才用do syntax來把兩個I/O action黏成一個。在<code>fmap</code>的實做中，我們先執行了原本傳進的I/O action，並把結果綁定成<code>result</code>。然後我們寫了<code>return (f result)</code>。<code>return</code>就如你所知道的，是一個只會回傳包了你傳給他東西的I/O action。還有一個do block的回傳值一定是他最後一個I/O action的回傳值。這也是為什麼我們需要return。其實他只是回傳包了<code>f result</code>的I/O action。</p><p>我們可以再多實驗一下來找到些感覺。來看看這段code：</p><pre class="code">main = do line <- getLine   
        let line' = reverse line  
        putStrLn $ "You said " ++ line' ++ " backwards!"  
        putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"</pre><p>這程式要求使用者輸入一行文字，然後印出一行反過來的。</p><p>我們可以用<code>fmap</code>來改寫：</p><pre class="code">main = do line <- fmap reverse getLine  
            putStrLn $ "You said " ++ line ++ " backwards!"  
            putStrLn $ "Yes, you really said" ++ line ++ " backwards!"</pre><img src="img/alien.png" style="float:left"></img><p>就像我們用<code>fmap</code><code>reverse</code>來map over<code>Just "blah"</code>會得到<code>Just "halb"</code>，我們也可以<code>fmap</code><code>reverse</code>來map over<code>getLine</code>。<code>getLine</code>是一個I/O action，他的type是<code>IO String</code>，而用<code>reverse</code>來map over他會回傳一個取回一個字串並<code>reverse</code>他的I/O action。就像我們apply一個function到一個<code>Maybe</code>一樣，我們也可以apply一個function到一個<code>IO</code>，只是這個<code>IO</code>會跑去外面拿回某些值。然後我們把結果用<code><-</code>綁定到某個名稱，而這個名稱綁定的值是已經<code>reverse</code>過了。</p><p>而<code>fmap (++"!") getLine</code>這個I/O action表現得就像<code>getLine</code>，只是他的結果多了一個<code>"!"</code>在最後。</p><p>如果我們限縮<code>fmap</code>到<code>IO</code>型態上，那fmap的型態是<code>fmap :: (a -> b) -> IO a -> IO b</code>。<code>fmap</code>接受一個函數跟一個I/O action，並回傳一個I/O action包含了已經apply過function的結果。</p><p>如果你曾經注意到你想要將一個I/O action綁定到一個名稱上，只是為了要apply一個function。你可以考慮使用<code>fmap</code>，那會更漂亮地表達這件事。或者你想要對functor中的資料做transformation，你可以先將你要用的function寫在top level，或是把他作成一個lambda function，甚至用function composition。</p><pre class="code">import Data.Char  
import Data.List  
  
main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine  
        putStrLn line</pre><pre class="code">$ runhaskell fmapping_io.hs  
hello there  
E-R-E-H-T- -O-L-L-E-H</pre><p>正如你想的，<code>intersperse '-' . reverse . map toUpper</code>合成了一個function，他接受一個字串，將他轉成大寫，然後反過來，再用<code>intersperse '-'</code>安插'-'。他是比較漂亮版本的<code>(\xs -> intersperse '-' (reverse (map toUpper xs)))</code>。</p><p>另一個<code>Functor</code>的案例是<code>(->) r</code>，只是我們先前沒有注意到。你可能會困惑到底<code>(->) r</code>究竟代表什麼？一個<code>r -> a</code>的型態可以寫成<code>(->) r a</code>，就像是<code>2 + 3</code>可以寫成<code>(+) 2 3</code>一樣。我們可以從一個不同的角度來看待<code>(->) r a</code>，他其實只是一個接受兩個參數的type constructor，好比<code>Either</code>。但記住我們說過<code>Functor</code>只能接受一個type constructor。這也是為什麼<code>(->)</code>不是<code>Functor</code>的一個instance，但<code>(->) r</code>則是。如果程式的語法允許的話，你也可以將<code>(->) r</code>寫成(r ->)。就如<code>(2+)</code>代表的其實是<code>(+) 2</code>。至於細節是如何呢？我們可以看看<code>Control.Monad.Instances</code>。</p><blockquote><p>我們通常說一個接受任何東西以及回傳隨便一個東西的函數型態是<code>a -> b</code>。<code>r -> a</code>是同樣意思，只是把符號代換了一下。</p></blockquote><pre class="code">instance Functor ((->) r) where  
    fmap f g = (\x -> f (g x))</pre><p>如果語法允許的話，他可以被寫成</p><pre class="code">instance Functor (r ->) where  
    fmap f g = (\x -> f (g x))</pre><p>但其實是不允許的，所以我們必須寫成第一種的樣子。</p><p>首先我們來看看<code>fmap</code>的型態。他的型態是<code>fmap :: (a -> b) -> f a -> f b</code>。我們把所有的<code>f</code>在心裡代換成<code>(->) r</code>。則<code>fmap</code>的型態就變成<code>fmap :: (a -> b) -> ((->) r a) -> ((->) r b)</code>。接著我們把<code>(->) r a</code>跟<code>(->) r b</code>換成<code>r -> a</code>跟<code>r -> b</code>。則我們得到<code>fmap :: (a -> b) -> (r -> a) -> (r -> b)</code>。</p><p>從上面的結果看到將一個function map over一個function會得到另一個function，就如map over一個function到<code>Maybe</code>會得到一個<code>Maybe</code>，而map over一個function到一個list會得到一個list。而<code>fmap :: (a -> b) -> (r -> a) -> (r -> b)</code>告訴我們什麼？他接受一個從<code>a</code>到<code>b</code>的function，跟一個從<code>r</code>到<code>a</code>的function，並回傳一個從<code>r</code>到<code>b</code>的function。這根本就是function composition。把<code>r -> a</code>的輸出接到<code>a -> b</code>的輸入，的確是function composition在做的事。如果你再仔細看看instance的定義，會發現真的就是一個function composition。</p><pre class="code">instance Functor ((->) r) where  
    fmap = (.)</pre><p>這很明顯就是把<code>fmap</code>當composition在用。可以用<code>:m + Control.Monad.Instances</code>把模組裝載進來，並做一些嘗試。</p><pre class="code">ghci> :t fmap (*3) (+100)  
fmap (*3) (+100) :: (Num a) => a -> a  
ghci> fmap (*3) (+100) 1  
303  
ghci> (*3) `fmap` (+100) $ 1  
303  
ghci> (*3) . (+100) $ 1  
303  
ghci> fmap (show . (*3)) (*100) 1  
"300"</pre><p>我們呼叫<code>fmap</code>的方式是infix的方式，這跟<code>.</code>很像。在第二行，我們把<code>(*3)</code>map over到<code>(+100)</code>上，這會回傳一個先把輸入值<code>(+100)</code>再<code>(*3)</code>的function，我們再用<code>1</code>去呼叫他。</p><p>到這邊為止盒子的比喻還適用嗎？如果你硬是要解釋的話還是解釋得通。當我們將<code>fmap (+3)</code>map over<code>Just 3</code>的時候，對於<code>Maybe</code>我們很容易把他想成是裝了值的盒子，我們只是對盒子裡面的值<code>(+3)</code>。但對於<code>fmap (*3) (+100)</code>呢？你可以把<code>(+100)</code>想成是一個裝了值的盒子。有點像把I/O action想成長了腳的盒子一樣。對<code>(+100)</code>使用<code>fmap (*3)</code>會產生另一個表現得像<code>(+100)</code>的function。只是在算出值之前，會再多計算<code>(*3)</code>。這樣我們可以看出來<code>fmap</code>表現得就像<code>.</code>一樣。</p><p><code>fmap</code>等同於function composition這件事對我們來說並不是很實用，但至少是一個有趣的觀點。這也讓我們打開視野，看到盒子的比喻不是那麼恰當，functors其實比較像computation。function被map over到一個computation會產生經由那個function映射過後的computation。</p><img src="img/lifter.png" style="float:right"></img><p>在我們繼續看<code>fmap</code>該遵守的規則之前，我們再看一次<code>fmap</code>的型態，他是<code>fmap :: (a -> b) -> f a -> f b</code>。很明顯我們是在討論Functor，所以為了簡潔，我們就不寫<code>(Functor f) =></code>的部份。當我們在學curry的時候，我們說過Haskell的function實際上只接受一個參數。一個型態是<code>a -> b -> c</code>的函數實際上是接受<code>a</code>然後回傳<code>b -> c</code>，而<code>b -> c</code>實際上接受一個<code>b</code>然後回傳一個<code>c</code>。如果我們用比較少的參數呼叫一個函數，他就會回傳一個函數需要接受剩下的參數。所以<code>a -> b -> c</code>可以寫成<code>a -> (b -> c)</code>。這樣curry可以明顯一些。</p><p>同樣的，我們可以不要把<code>fmap</code>想成是一個接受function跟functor並回傳一個function的function。而是想成一個接受function並回傳一個新的function的function，回傳的function接受一個functor並回傳一個functor。他接受<code>a -> b</code>並回傳<code>f a -> f b</code>。這動作叫做lifting。我們用GHCI的<code>:t</code>來做的實驗。</p><pre class="code">ghci> :t fmap (*2)  
fmap (*2) :: (Num a, Functor f) => f a -> f a  
ghci> :t fmap (replicate 3)  
fmap (replicate 3) :: (Functor f) => f a -> f [a]</pre><p><code>fmap (*2)</code>接受一個functor<code>f</code>，並回傳一個基於數字的functor。那個functor可以是list，可以是<code>Maybe</code>，可以是<code>Either String</code>。<code>fmap (replicate 3)</code>可以接受一個基於任何型態的functor，並回傳一個基於list的functor。</p><blockquote><p>當我們提到functor over numbers的時候，你可以想像他是一個functor包含有許多數字在裡面。前面一種說法其實比較正確，但後面一種說法比較容易讓人理解。</p></blockquote><p>這樣的觀察在我們只有綁定一個部份套用的函數，像是<code>fmap (++"!")</code>，的時候會顯得更清楚，</p><p>你可以把<code>fmap</code>想做是一個函數，他接受另一個函數跟一個functor，然後把函數對functor每一個元素做映射，或你可以想做他是一個函數，他接受一個函數並把他lift到可以在functors上面操作。兩種想法都是正確的，而且在Haskell中是等價。</p><p><code>fmap (replicate 3) :: (Functor f) => f a -> f [a]</code>這樣的型態代表這個函數可以運作在任何functor上。至於確切的行為則要看究竟我們操作的是什麼樣的functor。如果我們是用<code>fmap (replicate 3)</code>對一個list操作，那我們會選擇<code>fmap</code>針對list的實作，也就是只是一個<code>map</code>。如果我們是碰到<code>Maybe a</code>。那他在碰到<code>Just</code>型態的時候，會對裡面的值套用<code>replicate 3</code>。而碰到<code>Nothing</code>的時候就回傳<code>Nothing</code>。</p><pre class="code">ghci> fmap (replicate 3) [1,2,3,4]  
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]  
ghci> fmap (replicate 3) (Just 4)  
Just [4,4,4]  
ghci> fmap (replicate 3) (Right "blah")  
Right ["blah","blah","blah"]  
ghci> fmap (replicate 3) Nothing  
Nothing  
ghci> fmap (replicate 3) (Left "foo")  
Left "foo"</pre><p>接下來我們來看看functor laws。一個東西要成為functor，必須要遵守某些定律。不管任何一個functor都被要求具有某些性質。他們必須是能被map over的。對他們呼叫<code>fmap</code>應該是要用一個函數map每一個元素，不多做任何事情。這些行為都被functor laws所描述。對於<code>Functor</code>的instance來說，總共兩條定律應該被遵守。不過他們不會在Haskell中自動被檢查，所以你必須自己確認這些條件。</p><p>functor law的第一條說明，如果我們對functor做map<code>id</code>，那得到的新的functor應該要跟原來的一樣。如果寫得正式一點，他代表<code>fmap id = id</code>。基本上他就是說對functor呼叫<code>fmap id</code>，應該等同於對functor呼叫<code>id</code>一樣。畢竟<code>id</code>只是identity function，他只會把參數照原樣丟出。他也可以被寫成<code>\x -> x</code>。如果我們對functor的概念就是可以被map over的物件，那<code>fmap id = id</code>的性就顯而易見。</p><p>我們來看看這個定律的幾個案例：</p><pre class="code">ghci> fmap id (Just 3)  
Just 3  
ghci> id (Just 3)  
Just 3  
ghci> fmap id [1..5]  
[1,2,3,4,5]  
ghci> id [1..5]  
[1,2,3,4,5]  
ghci> fmap id []  
[]  
ghci> fmap id Nothing  
Nothing</pre><p>如果我們看看<code>Maybe</code>的<code>fmap</code>的實作，我們不難發現第一定律為何被遵守。</p><pre class="code">instance Functor Maybe where  
    fmap f (Just x) = Just (f x)  
    fmap f Nothing = Nothing</pre><p>我們可以想像在<code>f</code>的位置擺上<code>id</code>。我們看到<code>fmap id</code>拿到<code>Just x</code>的時候，結果只不過是<code>Just (id x)</code>，而<code>id</code>有只回傳他拿到的東西，所以可以知道<code>Just (id x)</code>等價於<code>Just x</code>。所以說我們可以知道對<code>Maybe</code>中的<code>Just</code>用<code>id</code>去做map over的動作，會拿回一樣的值。</p><p>而將<code>id</code>map over<code>Nothing</code>會拿回<code>Nothing</code>並不稀奇。所以從這兩個<code>fmap</code>的實作，我們可以看到的確<code>fmap id = id</code>有被遵守。</p><img src="img/justice.png" style="float:left"></img><pre class="code">data CMaybe a = CNothing | CJust Int a deriving (Show)</pre><pre class="code">ghci> CNothing  
CNothing  
ghci> CJust 0 "haha"  
CJust 0 "haha"  
ghci> :t CNothing  
CNothing :: CMaybe a  
ghci> :t CJust 0 "haha"  
CJust 0 "haha" :: CMaybe [Char]  
ghci> CJust 100 [1,2,3]  
CJust 100 [1,2,3]</pre><pre class="code">instance Functor CMaybe where  
    fmap f CNothing = CNothing  
    fmap f (CJust counter x) = CJust (counter+1) (f x)</pre><pre class="code">ghci> fmap (++"ha") (CJust 0 "ho")  
CJust 1 "hoha"  
ghci> fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))  
CJust 2 "hohahe"  
ghci> fmap (++"blah") CNothing  
CNothing</pre><pre class="code">ghci> fmap id (CJust 0 "haha")  
CJust 1 "haha"  
ghci> id (CJust 0 "haha")  
CJust 0 "haha"</pre><a name="Applicative functors"></a><h2>Applicative functors</h2><img src="img/present.png" style="float:right"></img><pre class="code">ghci> :t fmap (++) (Just "hey")  
fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])  
ghci> :t fmap compare (Just 'a')  
fmap compare (Just 'a') :: Maybe (Char -> Ordering)  
ghci> :t fmap compare "A LIST OF CHARS"  
fmap compare "A LIST OF CHARS" :: [Char -> Ordering]  
ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]  
fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]</pre><pre class="code">ghci> let a = fmap (*) [1,2,3,4]  
ghci> :t a  
a :: [Integer -> Integer]  
ghci> fmap (\f -> f 9) a  
[9,18,27,36]</pre><pre class="code">class (Functor f) => Applicative f where  
    pure :: a -> f a  
    (<*>) :: f (a -> b) -> f a -> f b</pre><pre class="code">instance Applicative Maybe where  
    pure = Just  
    Nothing <*> _ = Nothing  
    (Just f) <*> something = fmap f something</pre><pre class="code">ghci> Just (+3) <*> Just 9  
Just 12  
ghci> pure (+3) <*> Just 10  
Just 13  
ghci> pure (+3) <*> Just 9  
Just 12  
ghci> Just (++"hahah") <*> Nothing  
Nothing  
ghci> Nothing <*> Just "woot"  
Nothing</pre><pre class="code">ghci> pure (+) <*> Just 3 <*> Just 5  
Just 8  
ghci> pure (+) <*> Just 3 <*> Nothing  
Nothing  
ghci> pure (+) <*> Nothing <*> Just 5  
Nothing</pre><img src="img/whale.png" style="float:right"></img><pre class="code">(<$>) :: (Functor f) => (a -> b) -> f a -> f b  
f <$> x = fmap f x</pre><pre class="code">ghci> (++) <$> Just "johntra" <*> Just "volta"  
Just "johntravolta"</pre><pre class="code">ghci> (++) "johntra" "volta"  
"johntravolta"</pre><pre class="code">instance Applicative [] where  
    pure x = [x]  
    fs <*> xs = [f x | f <- fs, x <- xs]</pre><pre class="code">ghci> pure "Hey" :: [String]  
["Hey"]  
ghci> pure "Hey" :: Maybe String  
Just "Hey"</pre><pre class="code">ghci> [(*0),(+100),(^2)] <*> [1,2,3]  
[0,0,0,101,102,103,1,4,9]</pre><pre class="code">ghci> [(+),(*)] <*> [1,2] <*> [3,4]  
[4,5,5,6,3,4,6,8]</pre><pre class="code">ghci> (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]  
["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]</pre><pre class="code">ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]     
[16,20,22,40,50,55,80,100,110]</pre><pre class="code">ghci> (*) <$> [2,5,10] <*> [8,10,11]  
[16,20,22,40,50,55,80,100,110]</pre><pre class="code">ghci> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]  
[55,80,100,110]</pre><pre class="code">instance Applicative IO where  
    pure = return  
    a <*> b = do  
        f <- a  
        x <- b  
        return (f x)</pre><img src="img/knight.png" style="float:left"></img><pre class="code">myAction :: IO String  
myAction = do  
    a <- getLine  
    b <- getLine  
    return $ a ++ b</pre><pre class="code">myAction :: IO String  
myAction = (++) <$> getLine <*> getLine</pre><pre class="code">main = do  
    a <- (++) <$> getLine <*> getLine  
    putStrLn $ "The two lines concatenated turn out to be: " ++ a</pre><pre class="code">instance Applicative ((->) r) where  
    pure x = (\_ -> x)  
    f <*> g = \x -> f x (g x)</pre><pre class="code">ghci> (pure 3) "blah"  
3</pre><pre class="code">ghci> pure 3 "blah"  
3</pre><pre class="code">ghci> :t (+) <$> (+3) <*> (*100)  
(+) <$> (+3) <*> (*100) :: (Num a) => a -> a  
ghci> (+) <$> (+3) <*> (*100) $ 5  
508</pre><pre class="code">ghci> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5  
[8.0,10.0,2.5]</pre><img src="img/jazzb.png" style="float:right"></img><pre class="code">instance Applicative ZipList where  
        pure x = ZipList (repeat x)  
        ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)</pre><pre class="code">ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]  
[101,102,103]  
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100..]  
[101,102,103]  
ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]  
[5,3,3,4]  
ghci> getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"  
[('d','c','r'),('o','a','a'),('g','t','t')]</pre><pre class="code">liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c  
liftA2 f a b = f <$> a <*> b</pre><pre class="code">ghci> fmap (\x -> [x]) (Just 4)  
Just [4]</pre><pre class="code">ghci> liftA2 (:) (Just 3) (Just [4])  
Just [3,4]  
ghci> (:) <$> Just 3 <*> Just [4]  
Just [3,4]</pre><pre class="code">sequenceA :: (Applicative f) => [f a] -> f [a]  
sequenceA [] = pure []  
sequenceA (x:xs) = (:) <$> x <*> sequenceA xs</pre><pre class="code">sequenceA :: (Applicative f) => [f a] -> f [a]  
sequenceA = foldr (liftA2 (:)) (pure [])</pre><pre class="code">ghci> sequenceA [Just 3, Just 2, Just 1]  
Just [3,2,1]  
ghci> sequenceA [Just 3, Nothing, Just 1]  
Nothing  
ghci> sequenceA [(+3),(+2),(+1)] 3  
[6,5,4]  
ghci> sequenceA [[1,2,3],[4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]  
[]</pre><pre class="code">ghci> map (\f -> f 7) [(>4),(<10),odd]  
[True,True,True]  
ghci> and $ map (\f -> f 7) [(>4),(<10),odd]  
True</pre><pre class="code">ghci> sequenceA [(>4),(<10),odd] 7  
[True,True,True]  
ghci> and $ sequenceA [(>4),(<10),odd] 7  
True</pre><pre class="code">ghci> sequenceA [[1,2,3],[4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> [[x,y] | x <- [1,2,3], y <- [4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> sequenceA [[1,2],[3,4]]  
[[1,3],[1,4],[2,3],[2,4]]  
ghci> [[x,y] | x <- [1,2], y <- [3,4]]  
[[1,3],[1,4],[2,3],[2,4]]  
ghci> sequenceA [[1,2],[3,4],[5,6]]  
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]  
ghci> [[x,y,z] | x <- [1,2], y <- [3,4], z <- [5,6]]  
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]</pre><pre class="code">ghci> sequenceA [getLine, getLine, getLine]  
heyh  
ho  
woo  
["heyh","ho","woo"]</pre><a name="關鍵字"newtype""></a><h2>關鍵字"newtype"</h2><img src="img/maoi.png" style="float:left"></img><pre class="code">ghci> [(+1),(*100),(*5)] <*> [1,2,3]  
[2,3,4,100,200,300,5,10,15]</pre><pre class="code">ghci> getZipList $ ZipList [(+1),(*100),(*5)] <*> ZipList [1,2,3]  
[2,200,15]</pre><pre class="code">data ZipList a = ZipList [a]</pre><pre class="code">data ZipList a = ZipList { getZipList :: [a] }</pre><pre class="code">newtype ZipList a = ZipList { getZipList :: [a] }</pre><pre class="code">data Profession = Fighter | Archer | Accountant  
  
data Race = Human | Elf | Orc | Goblin  

data PlayerCharacter = PlayerCharacter Race Profession</pre><pre class="code">newtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)</pre><pre class="code">ghci> CharList "this will be shown!"  
CharList {getCharList = "this will be shown!"}  
ghci> CharList "benny" == CharList "benny"  
True  
ghci> CharList "benny" == CharList "oisters"  
False</pre><pre class="code">CharList :: [Char] -> CharList</pre><pre class="code">getCharList :: CharList -> [Char]</pre><img src="img/krakatoa.png" style="float:right"></img><pre class="code">class Functor f where  
    fmap :: (a -> b) -> f a -> f b</pre><pre class="code">instance Functor Maybe where</pre><pre class="code">fmap :: (a -> b) -> Maybe a -> Maybe b</pre><img src="img/shamrock.png" style="float:right"></img><pre class="code">newtype Pair b a = Pair { getPair :: (a,b) }</pre><pre class="code">instance Functor (Pair c) where  
    fmap f (Pair (x,y)) = Pair (f x, y)</pre><pre class="code">fmap :: (a -> b) -> Pair c a -> Pair c b</pre><pre class="code">class Functor f where  
    fmap :: (a -> b) -> f a -> f b</pre><pre class="code">ghci> getPair $ fmap (*100) (Pair (2,3))  
(200,3)  
ghci> getPair $ fmap reverse (Pair ("london calling", 3))  
("gnillac nodnol",3)</pre><pre class="code">ghci> undefined  
*** Exception: Prelude.undefined</pre><pre class="code">ghci> head [3,4,5,undefined,2,undefined]  
3</pre><pre class="code">data CoolBool = CoolBool { getCoolBool :: Bool }</pre><pre class="code">helloMe :: CoolBool -> String  
helloMe (CoolBool _) = "hello"</pre><a name="Monoids"></a><h2>Monoids</h2><img src="img/pirateship.png" style="float:right"></img><img src="img/balloondog.png" style="float:right"></img><img src="img/smug.png" style="float:left"></img><img src="img/bear.png" style="float:right"></img><img src="img/accordion.png" style="float:right"></img>
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="functionally-solving-problems.html">函數式地思考來解決問題</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="a-fistful-of-monads.html">來看看幾種Monad</a><img src="img/nxt.png"></img></li>
            </ul>
        </div>
        <div id="footer">
        </div>
        <div id="feedback">Send feedback</div>
    </body>
</html>
